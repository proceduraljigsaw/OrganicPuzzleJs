<!DOCTYPE html>
<html>

<head>
    <style>
        /* Style the tab */
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }

        /* Style the buttons that are used to open the tab content */
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }

        /* Change background color of buttons on hover */
        .tab button:hover {
            background-color: #ddd;
        }

        /* Create an active/current tablink class */
        .tab button.active {
            background-color: #ccc;
        }

        /* Style the tab content */
        .tabcontent {
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }

        /* 
         img.scaled {
         width: 100%;
         } */
        .center {
            margin-left: auto;
            margin-right: auto;
        }

        figure {
            text-align: center;
            font-style: italic;
            font-size: smaller;
            text-indent: 0;
        }
    </style>
    <meta charset="UTF-8">
    <title>CelljigsawJS</title>
    <script type="text/javascript" src="imagetracer.js"></script>
    <script type="text/javascript" src="flatten.js"></script>
    <script type="text/javascript">
        const lut = [false, true, true, true, true, false, true, true, true, true, false, true, false, false,
            false, true, true, false, false, false, true, false, true, true, false, false, false, false,
            false, false, false, true, true, false, false, false, false, false, false, false, true, true,
            false, true, false, false, false, true, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, false, true, true, false, false, false, false, false,
            false, false, false, false, false, false, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, false, false, false, false, false, false, true, false,
            false, false, false, false, false, false, true, true, false, true, false, false, false, true,
            false, false, false, false, false, false, false, false, false, false, false, false, false, false,
            false, false, true, false, false, false, false, false, false, false, false, false, false, false,
            false, false, false, false, true, false, false, false, true, false, true, true, false, false, false,
            false, false, false, false, true, false, false, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, false, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, false, true, false, false, false, true, false, true, true, false,
            false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, true,
            true, false, true, false, false, false, true, true, false, false, false, true, false, true, true, true, true,
            false, false, true, true, false, false];
        var xmldoc = null;
        var timerID;
        var autogrowth = false;
        var growthstep =0;
        var seed = 1;
        function $(id) { return document.getElementById(id); }
        function random() {
            if ($("ndr").checked) {
                return Math.random();
            } else {
                var x = Math.sin(seed) * 10000; seed += 1; return x - Math.floor(x);
            }
        }
        function updateseed() { $("_seed").value = $("seed").value; }
        function update_seed() { var val = parseInt($("_seed").value); if (!isNaN(val)) { $("seed").value = val; } updateseed(); }
        function uniform(min, max) { var ran = random(); return min + ran * (max - min); }
        function rbool() { return random() > 0.5; }
        function Shuffle(arr) {
            for (var i = arr.length - 1; i > 0; i--) {
                var j = Math.floor(random() * (i + 1)); //random index
                [arr[i], arr[j]] = [arr[j], arr[i]]; // swap
            }
        }

        function plotpath(path, scale) {
            var len = path.getTotalLength();
            var ancestor = path.ownerSVGElement;
            let cp = [];
            let uinc = 0.0078125;
            for (let u = 0; u <= 1; u += uinc) {
                let p = path.getPointAtLength(u * len);
                p.rx = p.x / scale;
                p.ry = p.y / scale;
                p.x = Math.round(p.x / scale);
                p.y = Math.round(p.y / scale);
                p.u = u;
                p.path = path;
                if (cp.length && (Math.abs(cp[cp.length - 1].x - p.x) > 1 || Math.abs(cp[cp.length - 1].y - p.y) > 1)) {
                    //Lacking raster resolution
                    u -= uinc;
                    uinc = uinc / 2;
                    //console.log("uinc " + uinc);
                    if (uinc < 0.0000152587890625) {
                        uinc = 0.0078125;
                        cp.push(p);
                    }
                } else {
                    cp.push(p);
                }

            }
            return cp;
        }

        class Automata {
            constructor(rows, columns) {
                this.rows = rows;
                this.columns = columns;
                this.max_growth_dist = 0;
                let Array2D = (row, col) => [...Array(row)].map(x => Array(col).fill(0));
                this.grid = Array2D(rows, columns);
                //this.edgegrid = Array2D(rows, columns);
                this.seedpoints = [];
                this.colorArray = [];
                this.cornertable = [];
                this.cornergrid = Array2D(rows, columns);
                this.maskgrid = Array2D(rows, columns);
                this.borderdistgrid = Array2D(rows, columns);
                this.lockedgrid = Array2D(rows, columns);
            }

            fillmask(paths, scale) {
                const crosslookup = [[-1, 0], [1, 0], [0, 1], [0, -1]];

                var allpts = []
                var minx, miny, maxx, maxy
                for (let p of paths) {
                    var pts = plotpath(p, scale);
                    pts.forEach((pt) => {
                        allpts.push(pt);
                        if (isNaN(minx) || pt.x < minx) minx = pt.x;
                        if (isNaN(miny) || pt.y < miny) miny = pt.y;
                        if (isNaN(maxx) || pt.x > maxx) maxx = pt.x;
                        if (isNaN(maxy) || pt.y > maxy) maxy = pt.y;
                    });

                }
                // console.log("V", minx, maxx, miny, maxy);
                allpts.forEach((p) => {
                    // console.log(this.borderdistgrid.length, this.borderdistgrid[0].length,p.x,p.y)
                    this.borderdistgrid[p.y][p.x] = { rx: p.rx + 0.5, ry: p.ry + 0.5 };
                    this.maskgrid[p.y][p.x] = 1;

                });

                var regnum = 3;

                var grown;
                do {
                    var outside = true;
                    grown = false;
                    for (var i = -1; i < this.rows + 1; i++) {
                        for (var j = -1; j < this.columns + 1; j++) {
                            if (i < 0 || j < 0 || i > this.rows - 1 || j > this.columns - 1 || (this.maskgrid[i][j] > 1 && this.maskgrid[i][j] < regnum)) {
                                var togrow = [{ r: i, c: j }];
                                do {
                                    var p = togrow.pop();
                                    crosslookup.forEach((c) => {
                                        var ii = p.r + c[0];
                                        var jj = p.c + c[1];
                                        if (ii >= 0 && jj >= 0 && ii < this.rows && jj < this.columns) {

                                            if (!this.maskgrid[ii][jj]) {
                                                togrow.push({ r: ii, c: jj });
                                            }
                                            if (this.maskgrid[ii][jj] < 2) {
                                                if (p.r > 0 && p.c > 0 && p.r < this.rows && p.c < this.columns) {
                                                    if (this.maskgrid[p.r][p.c] > 1 && this.maskgrid[p.r][p.c] < regnum && this.maskgrid[p.r][p.c] % 2) {
                                                        this.outside = false;
                                                    }
                                                } else {
                                                    this.outside = true;
                                                }
                                                this.maskgrid[ii][jj] = regnum;
                                                grown = true;
                                            }
                                        }
                                    });
                                } while (togrow.length);

                            }
                        }

                    }
                    regnum += outside ? 1 : 2;
                } while (grown)

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {
                        this.maskgrid[i][j] = this.maskgrid[i][j] % 2;
                    }
                }
                allpts.forEach((p) => {
                    this.maskgrid[p.y][p.x] = 1;
                });
            }
            gridseed(gsize, randlen) {
                this.seedpoints = []
                var val = 1;
                for (var i = gsize / 2; i <= this.rows - gsize / 2; i += gsize) {
                    for (var j = gsize / 2; j <= this.columns - gsize / 2; j += gsize) {
                        var row = Math.floor(i + uniform(-(gsize / 2) * randlen, (gsize / 2) * randlen)) % this.rows;
                        var col = Math.floor(j + uniform(-(gsize / 2) * randlen, (gsize / 2) * randlen)) % this.columns;
                        if (row < 0) row += this.rows;
                        if (col < 0) col += this.columns;

                        if (!this.maskgrid[row][col]) {
                            this.grid[row][col] = val;
                            this.seedpoints.push({ row: row, col: col, val: val });
                            val = val + 1;
                        }

                    }
                }
                $("piececount").innerHTML = val - 1;
            }

            step(context, prefill) {
                var growth = []
                var growthdistchanged = (this.max_growth_dist != parseInt($("gradius").value));
                var ii = Math.floor(uniform(0, this.rows));
                var ij = Math.floor(uniform(0, this.columns));
                var fi = ii + this.rows;
                var fj = ij + this.columns;
                var reverse = rbool() && !prefill;
                if (growthdistchanged) {
                    for (var i = 0; i < this.rows; i++) {
                        for (var j = 0; j < this.columns; j++) {
                            this.lockedgrid[i][j] = 0;
                        }
                    }
                }
                this.max_growth_dist = parseInt($("gradius").value);
                if (prefill) {
                    ii = 0;
                    ij = 0;
                    fi = this.rows;
                    fj = this.columns;
                }
                if (reverse) {
                    for (var i = fi - 1; i >= ii; i--) {
                        for (var j = fj - 1; j >= ij; j--) {
                            var ti = i % this.rows;
                            var tj = j % this.columns;
                            if (this.grid[ti][tj] > 0 && !this.lockedgrid[ti][tj]) {
                                this.grow(ti, tj, growth, context, prefill);
                            }
                        }
                    }
                } else {
                    for (var i = ii; i < fi; i++) {
                        for (var j = ij; j < fj; j++) {
                            var ti = i % this.rows;
                            var tj = j % this.columns;
                            if (this.grid[ti][tj] > 0 && !this.lockedgrid[ti][tj]) {
                                this.grow(ti, tj, growth, context, prefill);
                            }
                        }
                    }
                }
                growth.forEach((grow) => {
                    this.grid[grow.row][grow.col] = grow.val;
                    var neigh = this.neighbor_coords(grow.row, grow.col, false).c;
                    neigh.forEach((n) => {
                        this.lockedgrid[n.row][n.col] = 0;
                    });
                });
                // if (!prefill) {
                //     this.edgefind(context);
                // }
                return growth.length
            }

            mindistandclosestpoint2path(corner) {

                var neighbor_coords = this.neighbor_coords(corner.row, corner.col, false).c;
                neighbor_coords.push(corner);
                let mind = 1e12
                let cp = null;
                let d = 0;
                neighbor_coords.forEach((nc) => {
                    let bg = this.borderdistgrid[nc.row][nc.col];
                    if (bg) {
                        // var len = bg.path.getTotalLength();
                        // for (let u = bg.u - 0.01; u <= bg.u + 0.01; u += 0.005) {
                        //     let p = bg.path.getPointAtLength(u * len);
                        d = Math.hypot(bg.rx - corner.col, bg.ry - corner.row)
                        if (d < mind) {
                            mind = d;
                            cp = { x: bg.rx, y: bg.ry };
                        }
                        // }
                    }
                });

                return { d: mind, cp: cp };
            }


            neighbor_coords(row, col, calc_weights) {
                var coords = [];
                var weight = 0;
                for (var i = -1; i < 2; i++) {
                    for (var j = -1; j < 2; j++) {
                        var pr = row + i;
                        var pc = col + j;
                        if ((i || j) && pr >= 0 && pc >= 0 && pr < this.rows && pc < this.columns) {
                            coords.push({ row: pr, col: pc });
                            if (calc_weights && (Math.abs(this.grid[pr][pc]) == Math.abs(this.grid[row][col]))) {
                                var w = i + j * 3 + 4;
                                w = w > 4 ? w - 1 : w;
                                weight += (1 << w);
                            }
                        }
                    }
                }
                return { c: coords, w: weight };
            }

            findcorners(customborder) {
                const lookup = [[[1, 1], [0, 1], [1, 0]], [[-1, -1], [0, -1], [-1, 0]], [[1, -1], [0, -1], [1, 0]], [[-1, 1], [0, 1], [-1, 0]]];
                var corners = [];
                let Array2D = (row, col) => [...Array(row)].map(x => Array(col).fill(0));
                this.cornergrid = Array2D(this.rows + 1, this.columns + 1);
                for (var i = -1; i < this.rows + 1; i++) {
                    for (var j = -1; j < this.columns + 1; j++) {
                        var corner_cand = [];

                        lookup.forEach((le) => {
                            if (i < 0 || j < 0 || j >= this.columns || i >= this.rows) {
                                var distinct = [0];
                            } else {
                                var distinct = [this.grid[i][j]];

                            }
                            le.forEach((c) => {
                                var ii = i + c[0];
                                var jj = j + c[1];
                                if (ii < 0 || jj < 0 || ii >= this.rows || jj >= this.columns) {
                                    if (!distinct.includes(0)) {
                                        distinct.push(0);
                                    }
                                } else {
                                    var val = this.grid[ii][jj];
                                    if (!distinct.includes(val)) {
                                        distinct.push(val);
                                    }
                                }
                            });
                            if (distinct.length > 2) {
                                var c = le[0];
                                var cr = c[0] > 0 ? c[0] : 0;
                                var cc = c[1] > 0 ? c[1] : 0;
                                var onborder = distinct.includes(0);
                                corner_cand.push({ row: i + cr, col: j + cc, onborder: onborder });
                            }
                        });

                        if (corner_cand.length == 1 && !this.cornergrid[corner_cand[0].row][corner_cand[0].col]) {
                            this.cornergrid[corner_cand[0].row][corner_cand[0].col] = 1;
                            corners.push(corner_cand[0]);
                        }
                    }
                }
                this.cornertable = [];
                if (customborder.paths) {
                    corners.forEach((c) => {
                        if (c.onborder) {
                            var mind = 2e9;
                            var newp = { x: c.col, y: c.row };
                            for (let p of customborder.paths) {
                                var dcp = this.mindistandclosestpoint2path(c);
                                if (dcp && dcp.d < mind) {
                                    mind = dcp.d;
                                    newp = dcp.cp;
                                }
                            }
                            this.cornertable.push({ row: c.row, col: c.col, x: newp.x, y: newp.y });
                        }
                    });
                }
                return corners;
            }
            grow(row, col, growth, context, prefill) {

                var neigh_coord = this.neighbor_coords(row, col, false).c;
                var grown = [];
                var currentcellval = this.grid[row][col]
                var seed = this.seedpoints.find((sp) => sp.val == currentcellval);

                var sc_neigh = 0;
                var sc_neigh_in_corner = 0;
                var other_color = 0;
                neigh_coord.forEach((neighbor) => {
                    if (this.grid[neighbor.row][neighbor.col]) {
                        if (Math.abs(this.grid[neighbor.row][neighbor.col]) == currentcellval) {
                            sc_neigh++;
                            if (neighbor.row != row && neighbor.col != col) {
                                sc_neigh_in_corner++;
                            }
                        } else {
                            other_color = Math.abs(this.grid[neighbor.row][neighbor.col]);
                        }
                    }
                });
                if (sc_neigh == neigh_coord.length) {
                    this.lockedgrid[row][col] = 1;
                } else {
                    if (!prefill && sc_neigh < 3) {
                        //Cell dies immediately if it's alone (2 neighbors of the same color or less) We don't want it to grow
                        //This avoids issues with spurious growth
                        if (sc_neigh_in_corner == sc_neigh && !this.maskgrid[row][col]) {
                            this.grid[row][col] = -other_color;
                            growth.push({ row: row, col: col, val: other_color });
                        }
                    } else if (prefill || random() < parseFloat($("growth_prob").value)) {

                        //We have enough neighbors, explore them
                        neigh_coord.forEach((neighbor) => {
                            var neighborval = this.grid[neighbor.row][neighbor.col];

                            if (!this.maskgrid[neighbor.row][neighbor.col] && (prefill || ((Math.abs(currentcellval) != Math.abs(neighborval)) && (neighbor.row == row || neighbor.col == col)))) {
                                var dist2seed = Math.sqrt((neighbor.row - seed.row) ** 2 + (neighbor.col - seed.col) ** 2);

                                if (prefill || (dist2seed < this.max_growth_dist)) {
                                    //We're close enough to the seed point, lets try to grow

                                    if (!neighborval) { //neighbor is empty 
                                        //Just eat it  
                                        growth.push({ row: neighbor.row, col: neighbor.col, val: currentcellval });
                                        grown.push({ row: neighbor.row, col: neighbor.col });
                                    } else if (!prefill && neighborval > 0) { //neighbor is taken by other piece
                                        //see if we can kill it and overtake
                                        var nnc_cw = this.neighbor_coords(neighbor.row, neighbor.col, true);
                                        if (lut[nnc_cw.w]) {
                                            var nnc = nnc_cw.c

                                            //get neighbor's neighbors of the same color;
                                            nnc = nnc.filter(nn => (Math.abs(this.grid[nn.row][nn.col]) == neighborval));
                                            var nnc_len = nnc.length;
                                            if ($("ppg").checked || nnc_len < 6) {
                                                var nnnc_len = 0;
                                                nnc.forEach((n) => {
                                                    var nnnc = this.neighbor_coords(n.row, n.col).c;
                                                    nnnc = nnnc.filter(nn => (Math.abs(this.grid[nn.row][nn.col]) == neighborval));
                                                    nnnc_len += nnnc.length;
                                                });


                                                //I don't know how the 6.2 thing works, but it seems to work. This algorithm was empirically found
                                                if (nnnc_len / nnc_len > parseFloat($("mnumber").value)) {
                                                    //console.log(nnnc_len + " " + nnc_len + " " + neighborval);
                                                    growth.push({ row: neighbor.row, col: neighbor.col, val: currentcellval });
                                                    grown.push({ row: neighbor.row, col: neighbor.col });
                                                }
                                            }
                                        }
                                    }

                                }
                            }
                        });
                        // if (!prefill && grown.length == 0) {
                        //    // this.lockedgrid[row][col] = 1;
                        // }
                    }

                    //TODO: If your only growth is a corner, don't grow DONE
                    if (grown.length == 1 && grown[0].row != row && grown[0].col != col) {
                        grown = [];
                        growth.pop();
                    }
                    grown.forEach((grow) => {
                        this.grid[grow.row][grow.col] = -this.grid[row][col];
                    });
                }
            }
            paintcorners(context, corners, size) {
                var pixelsize = parseInt($("pixelscell").value);
                corners.forEach((c) => {
                    context.fillStyle = "black";
                    context.fillRect((c.col * pixelsize) - size / 2, (c.row * pixelsize) - size / 2, size, size);
                });
            }
            findedgestep(edge, row, col, pdir, corner, context) {
                var pixelsize = parseInt($("pixelscell").value);
                if (row < 0 || col < 0 || row >= this.rows || col >= this.columns) {
                    return;
                }
                if (!corner && this.cornergrid[row][col] == 1) {
                    return;
                }
                if (pdir.includes("E")) {
                    //move east
                    var ii = row - 1;
                    var jj = col;
                    var v1 = this.grid[row][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row][col + 1] < 2) {
                            if (!this.cornergrid[row][col + 1])
                                this.cornergrid[row][col + 1] = 2;
                            edge.push({ row: row, col: col + 1 });
                            context.strokeStyle = "black";
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo((col + 1) * pixelsize, (row) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row, col + 1, "NSE", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("W")) {
                    //move west
                    var ii = row - 1;
                    var jj = col - 1;
                    var v1 = (col - 1) < 0 ? 0 : this.grid[row][col - 1];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row][col - 1] < 2) {
                            if (!this.cornergrid[row][col - 1])
                                this.cornergrid[row][col - 1] = 2;
                            edge.push({ row: row, col: col - 1 });
                            context.strokeStyle = "black";
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo((col - 1) * pixelsize, (row) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row, col - 1, "NSW", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("N")) {
                    //move north
                    var ii = row - 1;
                    var jj = col - 1;
                    var v1 = (row - 1) < 0 ? 0 : this.grid[row - 1][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row - 1][col] < 2) {
                            if (!this.cornergrid[row - 1][col])
                                this.cornergrid[row - 1][col] = 2;
                            edge.push({ row: row - 1, col: col });
                            context.strokeStyle = "black";
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo(col * pixelsize, (row - 1) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row - 1, col, "NEW", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("S")) {
                    //move south
                    var ii = row;
                    var jj = col - 1;
                    var v1 = this.grid[row][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row + 1][col] < 2) {
                            if (!this.cornergrid[row + 1][col])
                                this.cornergrid[row + 1][col] = 2;
                            edge.push({ row: row + 1, col: col });
                            context.strokeStyle = "black";

                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo(col * pixelsize, (row + 1) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row + 1, col, "SEW", false, context);
                        }
                        return; //only one movement!
                    }

                }

            }
            findedges(corners, context) {
                var edgepaths = [];
                var shortedgepaths = [];
                const directions = ["N", "S", "E", "W"];
                var pixelsize = parseInt($("pixelscell").value);
                corners.forEach((c) => {

                    // var size = 8;
                    // context.fillStyle = c.customborder ? "red" : "blue";
                    // context.fillRect((c.col * pixelsize) - size / 2, (c.row * pixelsize) - size / 2, size, size);
                    // if (!c.customborder) {
                    directions.forEach((d) => {
                        var edge = [c];
                        this.findedgestep(edge, c.row, c.col, d, true, context);

                        if (edge.length > 1) {
                            if (edge.length == 2) {
                                var sameedge = shortedgepaths.filter(sep => (
                                    (sep[0].row == edge[0].row && sep[0].col == edge[0].col && sep[1].row == edge[1].row && sep[1].col == edge[1].col) ||
                                    (sep[1].row == edge[0].row && sep[1].col == edge[0].col && sep[0].row == edge[1].row && sep[0].col == edge[1].col)
                                ));
                                if (!sameedge.length) {
                                    edgepaths.push(edge);
                                    shortedgepaths.push(edge);
                                }
                            } else {
                                edgepaths.push(edge);
                            }
                        }
                        //.log("Edged");
                    });
                    // }
                });
                return edgepaths;
            }
            paint(context, palette) {
                var pixelsize = parseInt($("pixelscell").value);
                context.clearRect(0, 0, $("automata").width, $("automata").height);
                context.font = "12px Arial";
                context.textAlign = "center";

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {

                        if (this.grid[i][j] < 0) {
                            console.log("WTF");
                        }

                        if (this.grid[i][j]) {
                            context.fillStyle = this.colorArray[Math.abs(this.grid[i][j] - 1) % this.colorArray.length];
                            context.fillRect(j * pixelsize, i * pixelsize, pixelsize, pixelsize);

                        }
                    }
                }
            }

            paintmask(context, paths) {
                var pixelsize = parseInt($("pixelscell").value);
                context.clearRect(0, 0, $("automata").width, $("automata").height);
                context.font = "12px Arial";
                context.textAlign = "center";

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {

                        if (this.maskgrid[i][j] < 0) {
                            console.log("WTF");
                        }

                        if (this.maskgrid[i][j] % 2) {
                            context.fillStyle = "red";

                        } else {
                            context.fillStyle = "blue";
                        }

                        context.fillRect(j * pixelsize, i * pixelsize, pixelsize, pixelsize);



                    }
                }
                for (let p of paths) {
                    var p2d = new Path2D(p.getAttribute("d"));
                    context.stroke(p2d);
                }
            }
        }
        var canvas;
        var automata;
        var palette;
        var svgstr;
        var svgstrsave;
        var context;
        var customborder = {};
        // save function pieced together from here: https://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link
        function save(filename, data) {
            var blob = new Blob([data], { type: "image/svg+xml" });
            if (window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveBlob(blob, filename);
            }
            else {
                var elem = window.document.createElement('a');
                elem.href = window.URL.createObjectURL(blob);
                elem.download = filename;
                document.body.appendChild(elem);
                elem.click();
                document.body.removeChild(elem);
            }
        }

        function savesvg() {
            save("jigsaw.svg", svgstrsave);
        }

        function generate() {
            update_seed();
            seed = parseInt($("_seed").value);
            var pixelsize = parseInt($("pixelscell").value);
            var rows = parseInt($("nrows").value);
            var cols = parseInt($("ncols").value);
            var gsize = parseInt($("gsize").value);
            var gnoise = parseFloat($("gnoise").value);
            var cell_scale = parseFloat($("cell_scale").value)

            if (customborder.svgdata) {
                while ($("svgcontainer").firstChild) {
                    $("svgcontainer").removeChild($("svgcontainer").firstChild);
                }

                var svgdata = document.body.appendChild(customborder.svgdata);
                //Initial flattening to get rid of transforms
                flatten(svgdata, false, true);

                var paths_svg = svgdata.getElementsByTagName("path");
                var pgroup = document.createElementNS($("svgcontainer").namespaceURI, "g");
                //When all transforms have been applied for all paths, the remaining one is the viewbox/viewport thing
                var vt = paths_svg[0].getCTM();
                $("svgcontainer").append(pgroup);

                for (let p of paths_svg) {
                    var newpath = document.createElementNS($("svgcontainer").namespaceURI, "path")
                    newpath.setAttribute("d", p.getAttribute('d'));
                    newpath.setAttribute("stroke", "black");
                    newpath.setAttribute("stroke-width", 1);
                    newpath.setAttribute("fill", "none");
                    pgroup.appendChild(newpath);
                }

                document.body.removeChild(svgdata);
                //De-viewboxfy
                pgroup.setAttribute("transform", "matrix(" + vt.a + "," + vt.b + "," + vt.c + "," + vt.d + "," + vt.e + "," + vt.f + ")");
                flatten($("svgcontainer"), false, true);
                //Scale
                pgroup.setAttribute("transform", "scale(" + parseFloat($("cbsf").value) + ")");
                flatten($("svgcontainer"), false, true);
                //To left corner
                pgroup.setAttribute("transform", "translate(" + (-($("svgcontainer").getBBox().x)) + "," + (-($("svgcontainer").getBBox().y)) + ")");
                flatten($("svgcontainer"), false, true);
                //Now the customborder is normalized

                customborder.width = ($("svgcontainer").getBBox().width + $("svgcontainer").getBBox().x);// * pixelsize;
                customborder.height = ($("svgcontainer").getBBox().height + $("svgcontainer").getBBox().y);// * pixelsize;

                customborder.paths = pgroup.getElementsByTagName("path");

                cols = Math.ceil(customborder.width / cell_scale) + 1;
                rows = Math.ceil(customborder.height / cell_scale) + 1;

            }

            if (rows * cols > 1e6) {
                var extra_text = "\nHint: Try reducing the number of rows and columns until rows times columns is less than 1 million.\n";
                if (customborder.svgdata) {
                    var max_scale = parseFloat($("cbsf").value) / Math.sqrt((rows * cols) / 1e6);
                    extra_text = "\nHint: Try reducing the custom border scale factor. The maximum value recommended for your custom border is " + max_scale.toFixed(2) + ".\n";
                }
                var confirmed = window.confirm("You are going to generate a " + Math.round(rows) + " x " + Math.round(cols) + " cell jigsaw. This is very large, and " +
                    "it may take a very long time to generate or even lock your browser. Just close it if this happens." + extra_text + "Do you want to continue generating the jigsaw?");
                if (!confirmed) {
                    return;
                }
            }

            automata = new Automata(rows, cols);

            if (customborder.paths) {
                automata.fillmask(customborder.paths, cell_scale);
                pgroup.setAttribute("transform", "translate(" + (cell_scale / 2) + "," + (cell_scale / 2) + ")");
                flatten($("svgcontainer"), false, true);
            }



            canvas = $("automata");
            canvas.setAttribute("width", cols * pixelsize + 5);
            canvas.setAttribute("height", rows * pixelsize + 5);// * 2);


            if (canvas.getContext) {
                context = canvas.getContext('2d');


                // if (customborder.paths) {
                //     automata.paintmask(context,customborder.paths);
                // }
                automata.gridseed(gsize, gnoise);
                palette = ImageTracer.generatepalette(automata.seedpoints.length + 1);
                Shuffle(palette);
                palette.forEach((c) => {
                    automata.colorArray.push("#" + c.r.toString(16).toUpperCase().padStart(2, "0") + c.g.toString(16).toUpperCase().padStart(2, "0") + c.b.toString(16).toUpperCase().padStart(2, "0"));
                });

                automata.paint(context, palette);
                var growncells = 0;
                do {
                    growncells = automata.step(context, true);
                    //automata.paint(context);
                } while (growncells);
                paintoutput();
            }
            updatedimensions(1);
            growthstep=0;
            $("grs").innerHTML = growthstep;
        }

        function paintoutput() {
            var rows = automata.rows;
            var cols = automata.columns;
            var pixelsize = parseInt($("pixelscell").value);
            var cellscale = parseFloat($("cell_scale").value);
            canvas = $("automata");
            canvas.setAttribute("width", cols * pixelsize + 5);
            canvas.setAttribute("height", rows * pixelsize + 5);// * 2);
            $("svgcontainer").setAttribute("width", cols * cellscale);
            $("svgcontainer").setAttribute("height", rows * cellscale);
            automata.paint(context, palette);
            // console.log("Painted");
            var corners = automata.findcorners(customborder);
            // console.log("Cornered");

            var edges = automata.findedges(corners, context);
            // console.log("Edged");

            var paths = [];
            //convert to how svgtracejs wants this
            edges.forEach((e) => {
                var path = {};
                path.points = [];
                path.boundingbox = [];
                path.holechildren = [];
                path.isholepath = false;
                for (var i = 0; i < e.length; i++) {
                    var p = e[i];

                    // if(path.points.length){
                    //     var lp = path.points[path.points.length-1];
                    //     var deltax = (p.col -lp.x)/50;
                    //     var deltay = (p.row -lp.y)/50;
                    //     for (var i =1; i<50;i++){
                    //         path.points.push({ x: lp.x + i*deltax, y: lp.y+i*deltay });
                    //         //console.log({ x: lp.x + i*deltax, y: lp.y+i*deltay })
                    //     }
                    // }
                    if ($("cps").checked && i > 0 && i < e.length - 1) {
                        var d1 = [e[i].col - e[i - 1].col, e[i].row - e[i - 1].row];
                        var d2 = [e[i + 1].col - e[i].col, e[i + 1].row - e[i].row];
                        if ((d1[0] + d2[0]) != 0 && (d1[1] + d2[1]) != 0) {
                            var plast = path.points[path.points.length - 1];
                            var p1n = { x: e[i - 1].col + d1[0] / 2, y: e[i - 1].row + d1[1] / 2 };
                            var p2n = { x: e[i].col + d2[0] / 2, y: e[i].row + d2[1] / 2 };
                            if (!(p1n.x == plast.x && p1n.y == plast.y)) {
                                path.points.push(p1n);
                            } else if ($("scp").checked) {
                                var pplast = path.points[path.points.length - 2];
                                if (pplast.x == p2n.x || pplast.y == p2n.y) {
                                    path.points.pop();
                                }
                            }
                            path.points.push(p2n);
                        } else {
                            path.points.push({ x: p.col, y: p.row });
                        }
                    } else {
                        path.points.push({ x: p.col, y: p.row });

                        if ($("scp").checked && i < e.length - 3) {
                            var d1 = [e[i + 1].col - e[i].col, e[i + 1].row - e[i].row];
                            var d2 = [e[i + 3].col - e[i + 2].col, e[i + 3].row - e[i + 2].row];
                            var csum = Math.abs(d1[0] + d2[0]) + Math.abs(d1[1] + d2[1]);
                            if (!csum) {
                                path.points.push({ x: p.col + d1[0] / 2, y: p.row + d1[1] / 2 });
                                path.points.push({ x: e[i + 3].col - d2[0] / 2, y: e[i + 3].row - d2[1] / 2 });
                                i = i + 2;
                            }
                        }
                    }
                }

                paths.push(path);
  
            });
            var options = { pal: palette, scale: cellscale, ltres: parseFloat($("ltres").value), qtres: parseFloat($("qtres").value), strokewidth: .5, linefilter: false, rightangleenhance: false, layering: 0, layercontainerid: "layercnt" };

            // Getting ImageData from canvas with the helper function getImgdata().
            [svgstr, svgstrsave] = ImageTracer.pathsToSVG(paths, customborder, automata.cornertable, automata.columns, automata.rows, options);
            // console.log("SVG'd");

            // Synchronous tracing to SVG string 
            //var svgstr = ImageTracer.gridToSVG(automata.grid, palette, options);
            while ($("svgcontainer").firstChild) {
                $("svgcontainer").removeChild($("svgcontainer").firstChild);
            }
            // Appending SVG
            ImageTracer.appendSVGString(svgstr, 'svgcontainer');

            if ($("stv").checked) {
                var parser = new DOMParser();
                xmldoc = parser.parseFromString(svgstr, "image/svg+xml");
                var svgjig = xmldoc.getElementsByTagName("svg")[0];
                var outpaths = svgjig.getElementsByTagName("path");
                context.strokeStyle = "black";
                context.lineWidth = 2*(cellscale/pixelsize);
                context.scale((pixelsize / cellscale), (pixelsize / cellscale))
                for (let p of outpaths) {
                    var p2d = new Path2D(p.getAttribute("d"));
                    context.stroke(p2d);
                }
            }
            updatedimensions();
        }



        function growstep() {
            growncells = automata.step(context, false);
            // console.log("Grown");
            growthstep++;
            $("grs").innerHTML = growthstep;
            paintoutput();

        }
        function stopautogrow() {
            if (autogrowth) {
                toggleautogrow();
            }
        }
        function toggleautogrow() {
            if (automata) {
                autogrowth = !autogrowth;
                if (autogrowth) {
                    timerID = setTimeout(function () {
                        growstep();
                        timerID = setTimeout(arguments.callee, 1)
                    }, 1);
                    $("autogrow").innerHTML = "Stop Automatic Growth";
                } else {
                    clearTimeout(timerID);
                    $("autogrow").innerHTML = "Start Automatic Growth";
                }
            }
        }

        function unloadborder() {
            customborder = {};
            updatedimensions();
        }
        function updatedimensions(gen) {
            var width_mm = 0;
            var height_mm = 0;
            if (customborder.svgdata) {
                if (customborder.width) {
                    width_mm = (customborder.width);
                    height_mm = (customborder.height);
                } else {
                    $("dimensions").innerHTML = "Generate to know";
                    return;
                }

            } else {
                width_mm = parseInt($("ncols").value) * parseFloat($("cell_scale").value);
                height_mm = parseInt($("nrows").value) * parseFloat($("cell_scale").value);
            }
            $("dimensions").innerHTML = Math.round(width_mm) + " x " + Math.round(height_mm);
        }

        function loadborder() {
            var borderfile = $("borderfile");
            var fr = new FileReader();
            fr.readAsText(borderfile.files[0]);
            fr.onload = function () {
                //console.log(fr.result);
                var parser = new DOMParser();
                xmldoc = parser.parseFromString(fr.result, "image/svg+xml");
                var svgdata_p = xmldoc.getElementsByTagName("svg")[0];
                customborder.svgdata = svgdata_p;
                updatedimensions();
            };
        }
        function switchtab(evt, tab) {
            // Declare all variables
            var i, j, tabcontent, tablinks;
            stopautogrow()

            if (tab == "rect") {
                unloadborder();
            }
            if (tab == "help") {
                tabcontent = document.getElementsByClassName("help");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].removeAttribute("style");
                }
                tabcontent = document.getElementsByClassName("controltable");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].style.display = "none";
                }
            } else {
                tabcontent = document.getElementsByClassName("help");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].style.display = "none";
                }
                tabcontent = document.getElementsByClassName("controltable");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].removeAttribute("style");
                }
                // Get all elements with class="tabcontent" and hide them
                tabcontent = document.getElementsByClassName("controltable");
                for (i = 0; i < tabcontent.length; i++) {
                    rowelems = tabcontent[i].rows;
                    for (j = 0; j < rowelems.length; j++) {
                        if (!rowelems[j].className || rowelems[j].className == tab) {
                            rowelems[j].removeAttribute("style")
                        } else {
                            rowelems[j].style.display = "none"
                        }
                    }
                }

            }
            // Get all elements with class="tablinks" and remove the class "active"
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            // Show the current tab, and add an "active" class to the button that opened the tab
            // document.getElementById(tab).style.display = "block";
            evt.currentTarget.className += " active";

            if (tab == "custom" && !customborder.width) {
                window.alert("Please choose a custom SVG border file");
                document.getElementById("borderfile").click();
            }
        }


    </script>
</head>

<body onload="$('seed').value = random() * 10000; updateseed();">

    <div class="tab">
        <button class="tablinks" id="default" onclick="switchtab(event, 'rect')">Rectangular border</button>
        <button class="tablinks" onclick="switchtab(event, 'custom')">Custom border</button>
        <button class="tablinks" onclick="switchtab(event, 'help')">Help</button>
    </div>
    <div class="tabcontent">
        <table class="controltable">
            <tr class="custom">
                <td>SVG border file:</td>
                <td><input type="file" id="borderfile" accept=".svg" onchange="loadborder()"></td>
            </tr>
            <tr class="custom">
                <td>Custom border scale factor:</td>
                <td><input id="cbsf" onchange="updatedimensions(0)" type="text" value="1" size="5" /></td>
            </tr>
            <tr class="rect">
                <td>Columns:</td>
                <td><input id="ncols" onchange="updatedimensions(0)" type="text" value="100" size="5" /> cells</td>
            </tr>
            <tr class="rect">
                <td>Rows:</td>
                <td><input id="nrows" onchange="updatedimensions(0)" type="text" value="100" size="5" /> cells</td>
            </tr>
            <tr>
                <td>Seed:</td>
                <td><input id="_seed" type="text" value="0" onchange="update_seed()" /></td>
                <td><input id="seed" type="range" value="0" min="0" max="9999" step="1" onchange="updateseed()" /></td>
            </tr>
            <tr>
                <td>Use non-deterministic randomness:</td>
                <td><input id="ndr" type="checkbox" />(seed is ignored if ticked)</td>
            </tr>
            <tr>
                <td>Grid size:</td>
                <td><input id="gsize" type="text" value="10" size="5" /> cells</td>
            </tr>
            <tr>
                <td>Initial Grid position noise (0 to 1):</td>
                <td><input id="gnoise" type="text" value="0.9" size="5" /></td>
            </tr>
            <tr>
                <td>Growth radius:</td>
                <td><input id="gradius" type="text" value="20" size="5" /> cells</td>
            </tr>
            <tr>
                <td>Curve fitting threshold (>0, decimal):</td>
                <td><input id="qtres" type="text" value="1" size="5" /></td>
            </tr>
            <tr>
                <td>Straight line fitting threshold (>0, decimal):</td>
                <td><input id="ltres" type="text" value="0.00001" size="5" /></td>
            </tr>
            <tr>
                <td>Smooth choke points:</td>
                <td><input id="scp" type="checkbox" /></td>
            </tr>
            <tr>
                <td>Corner pre-smooth:</td>
                <td><input id="cps" type="checkbox" /></td>
            </tr>
            <tr>
                <td>"Pointy" piece growth:</td>
                <td><input id="ppg" type="checkbox" /></td>
            </tr>
            <tr>
                <td>Show traced vectors over preview</td>
                <td><input id="stv" type="checkbox" /></td>
            </tr>
            <tr>
                <td>Magic number(just leave it at 6.2):</td>
                <td><input id="mnumber" type="text" value="6.2" size="5" /></td>
            </tr>
            <tr>
                <td>Growth probability (0 to 1):</td>
                <td><input id="growth_prob" type="text" value="0.5" size="5" /></td>
            </tr>
            <tr>
                <td>Actual cell size:</td>
                <td><input id="cell_scale" onchange="updatedimensions(0)" type="text" value="2" size="5" /> mm</td>
            </tr>
            <tr>
                <td>Cell preview scale:</td>
                <td><input id="pixelscell" type="text" value="2" size="5" /> pixels/cell</td>
            </tr>
            <!-- <tr class="custom">
                <td><button onclick="loadborder()">Load custom border</button></td>
                <td><button onclick="unloadborder()">Unload custom border</button></td>
            </tr> -->
            <tr>
                <td><button onclick="generate()">Generate Jigsaw</button></td>
            </tr>
            <tr>
                <td><button onclick="growstep()">Grow Jigsaw Manually</button></td>
                <td><button id="autogrow" onclick="toggleautogrow()">Start Automatic Growth</button></td>
            </tr>
            <tr>
                <td><button onclick="savesvg()">Download SVG (non-overlapping vectors)</button></td>
            </tr>
            <tr>
                <td>This jigsaw has: <label id="piececount">0</label> pieces</td>
            </tr>
            <tr>
                <td>Jigsaw dimensions: <label id="dimensions">200 x 200</label> mm</td>
            </tr>
            <tr>
                <td>Growth step: <label id="grs">0</label></td>
            </tr>
        </table>
        <div class="help">
            <h2>How it works</h2>
            <h3>Basic Initial setup</h3>
            <p>This jigsaw generator is based on a cellular automaton. A <a
                    href="https://en.wikipedia.org/wiki/Cellular_automaton">cellular automaton</a> consists of simulated
                &quot;cells&quot; living in a grid, and their life cycle behavior is set by some usually simple rules.
                In
                this
                case, we simulate colonies of different types of cells,
                that get to live, eat other cells and get eaten, competing with other species in their &quot;grid
                world&quot; to be the most abundant. This is all governed by randomness, so every jigsaw generated is
                unique
                and
                can't be regenerated (well... this is not entirely true but let's not go down that rabbit hole). It all
                starts
                with a blank
                rectangular grid, where the cells will live. Each grid spot can only be occupied by one cell, like in
                this
                27x27
                world:
            </p>
            <figure>
                <img src="assets/20220430_231430_grid.png" width="270" title="Grid world for our cells">
                <figcaption>
                    Grid world for our cells
                </figcaption>
            </figure>
            <p>The grid world is subdivided into a subgrid of regions of <em><strong>Grid size</strong></em> by
                <em><strong>Grid
                        size</strong></em> cells in size, like this example below, where the 27x27 cell world is
                subdivided
                into
                9x9
                cell square regions. When the division isn't even (in this case it is, as 9 evenly divides 27), the last
                row
                and
                column of this subgrid may be smaller or larger to compensate.
            </p>
            <figure>
                <img src="assets/20220430_232259_gridsize.png" width="270" title="Region subgrid">
                <figcaption>
                    Region subgrid
                </figcaption>
            </figure>
            <p>Now, when you press <strong>Generate Jigsaw</strong> seed cells are planted, exactly one per subgrid
                region.
                Each
                seed cell is a different species, represented
                by its color.
                All cell species behave in exactly the same way, distinguishing their own kind from the rest based on
                their
                color.
                Where the seed is planted within its region is controlled by the <em><strong>Initial Grid position
                        noise</strong></em> parameter. This parameter can take any
                decimal value from 0 to 1 and means how much randomness is added to the placement of the seed. If you
                set
                this
                parameter to zero (left) the seeds will be planted in the center of their region (or a bit shifted if
                <strong><em>Grid
                        size</em> </strong>is even). Increasing <em><strong>Initial Grid position noise</strong></em>
                values
                enlarge the
                area
                around the regional center where the seed may be planted, up to the region borders when it approaches 1,
                as
                shown
                below:
            </p>
            <table class="center">
                <tr>
                    <td>
                        <figure>
                            <img src="assets/20220430_233100_seeding0noise.png" width="270"
                                title="Initial grid position noise: 0">
                            <figcaption>
                                Initial grid position noise: 0
                            </figcaption>
                        </figure>
                    </td>
                    <td>
                        <figure>
                            <img src="assets/20220430_233109_seeding03noise.png" width="270"
                                title="Initial grid position noise: 0.3">
                            <figcaption>
                                Initial grid position noise: 0.3
                            </figcaption>
                        </figure>
                    </td>
                </tr>
            </table class="center">
            <tr>
                <td>
                    <figure>
                        <img src="assets/20220430_233123_seeding10noise.png" width="270"
                            title="Initial grid position noise: 1.0">
                        <figcaption>
                            Initial grid position noise: 1.0
                        </figcaption>
                    </figure>
                </td>
            </tr>
            </table>
            <p>Please note that the seeding process is totally random, so it's possible (although unlikely) to get a
                perfectly
                even
                seed distribution with high values of <em><strong>Initial Grid position noise</strong></em>. In essence,
                more
                <em><strong>Initial Grid position noise</strong></em> means more irregular and uneven seeding patterns,
                which
                will
                lead to more irregular initial growth patterns.
            </p>
            <p>After the seeds have been planted, the cells start multiplying trying to conquer as much territory as
                possible.
                For
                now, their only goal is to fill their world leaving no space unconquered. Cells start multiplying and
                their
                spawn
                starts conquering the neighboring places, until the whole world is filled with cells. For now, cells
                don't eat
                each other, they just grow to form the initial growth pattern, unrestricted, until the world is full of
                cells,
                like
                this:
            </p>
            <figure>
                <img src="assets/20220430_234012_grow_noise_movie.gif" width="270" title="Initial growth phase">
                <figcaption>
                    Initial growth phase
                </figcaption>
            </figure>
            <h3>Jigsaw growth</h3>
            <p>
                Once the initial growth has been established, the cells may start eating each other forming the
                intricate,
                organic jigsaw puzzle patterns. Every time you
                press the <strong>Grow Jigsaw Manually</strong> button, or continuously as fast as your browser can go
                if
                you
                <strong>Start Automatic Growth</strong>, every cell in the border of its region is proposed for
                growth, with <em><strong>Growth probability</strong></em>.
                If <em><strong>Growth probability</strong></em> equals 0, no cell will ever grow, the world will remain
                stale in
                its initial state
                and no jigsaw puzzle patterns will emerge. <em><strong>Growth probability</strong></em> is set to 1,
                every
                single region-border cell will try to grow, eating neighboring cells and conquering
                their region. Anything in between essentially regulates growth speed.
            </p>
            <p>
                Cells aren't guaranteed to grow, even if they are selected for growth, they will only be able to divide
                and
                conquer neighboring spots by eating the resident
                cell from other species in that spot. However, there are restrictions on which cells can be eaten. The
                idea
                behind the algorithm is to allow eating neighboring
                cells of a different species (color) as long as that doesn't split the attacked colony in two, i.e. that
                each
                and every cell of one
                color remains attached to at least one cross neighbor of the same color. In this case, corner neighbor
                attachments don't count as attachments.
            </p>
            <p>
                There's also another limitation, as cell colonies aren't allowed to grow farther than <em><strong>Growth
                        radius</strong></em> units away from the initial seed
                position of the colony (they are initially allowed to conquer as much territory as they want, until the
                whole
                grid world is filled). This means that no places too far away from the initial seed point will be eaten
                by
                the
                colony, limiting the extent of its growth. This
                avoids growing too long and thin dendrites or tentacles, which make less robust, more fragile, and
                potentially
                too intricate jigsaw pieces. This parameter has to be
                changed depending on the selected <em><strong>Grid size</strong></em>. A larger <em><strong>Grid
                        size</strong></em> requires a larger <em><strong>Growth radius</strong></em>,
                or else nothing will grow or the growth will be too limited, so the pieces won't form interlocking
                dendrites.
                The example below shows the effects of <em><strong>Growth radius</strong></em>.
                The initial seed position of the red colony is shown, along with a circle representing the maximum
                growth
                radius
                for this colony. Increasing the <em><strong>Growth radius</strong></em> enlarges
                the potential extent of the colony growth.
            </p>
            <table class="center">
                <tr>
                    <td>
                        <figure>
                            <img src="assets/gr0.png" width="270" title="Initial growth. Growth radius = 8">
                            <figcaption>
                                Initial state. Growth radius = 8
                            </figcaption>
                        </figure>
                    </td>
                    <td>
                        <figure>
                            <img src="assets/gr1.png" width="270" title="Final state with growth radius = 8">
                            <figcaption>
                                Final state with growth radius = 8
                            </figcaption>
                        </figure>
                    </td>
                </tr>
                <tr>
                    <td>
                        <figure>
                            <img src="assets/gr2.png" width="270" title="Growth after extending growth radius to 12">
                            <figcaption>
                                Growth after extending growth radius to 12
                            </figcaption>
                        </figure>
                    </td>
                    <td>
                        <figure>
                            <img src="assets/gr3.png" width="270" title="Growth after extending growth radius to 18">
                            <figcaption>
                                Growth after extending growth radius to 18
                            </figcaption>
                        </figure>
                    </td>
                </tr>
            </table>
            <p>
                The growing algorithm behavior is governed by a parameter that acts as a magic number. For some reason,
                setting
                this parameter (<em><strong>Magic number</strong></em>) to around 6.2 makes everything work.
                Setting it to other values makes it not work. I left it there for you to play and see what happens if
                you
                dare
                to change its value.
            </p>
            <h3>Jigsaw vectorization</h3>
            <p>
                The jigsaw pieces are generated by tracing and vectorizing the borders of the cell colonies. The
                algorithm
                finds
                the borders between all regions
                and fits <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">quadratic bezier</a> curves and
                straight-line
                segments with configurable
                accuracy. As the cells are considered square, the border between regions is a jagged staircase pattern.
                The
                vectorizer tries to infer curves from the
                staircase patterns to smooth out the border and give the pieces their characteristic organic look. The
                "jaggedness" of the resulting vectorization
                can be controlled by the <em><strong>Curve fitting threshold</strong></em> value. Lower values of
                <em><strong>Curve fitting threshold</strong></em> yield
                more jagged results with more straight line segments, while higher values fit more curves. See the
                example
                below
                for the same growth pattern, vectorized
                with different <em><strong>Curve fitting threshold</strong></em> values. Please note that too high
                values of
                <em><strong>Curve fitting threshold</strong></em>
                are prone to create intersections or very narrow choke points, so I wouldn't recommend setting it much
                higher than
                1. Also, the parameter acts kind of
                logarithmically. There's a much more noticeable change from 0.2 to 1 than there is from 1 to 10, or from
                10
                to 10
                million.
            </p>
            <figure>
                <img src="assets/pattern.png" width="270" title="Growth pattern">
                <figcaption>
                    Growth pattern
                </figcaption>
            </figure>
            <table class="center">
                <tr>
                    <td>
                        <figure>
                            <img src="assets/cft001.png" width="270" title="Curve fitting threshold = 0.001">
                            <figcaption>
                                Curve fitting threshold = 0.001
                            </figcaption>
                        </figure>
                    </td>
                    <td>
                        <figure>
                            <img src="assets/cft02.png" width="270" title="Curve fitting threshold = 0.2">
                            <figcaption>
                                Curve fitting threshold = 0.2
                            </figcaption>
                        </figure>
                    </td>
                </tr>
                <tr>
                    <td>
                        <figure>
                            <img src="assets/cft1.png" width="270" title="Curve fitting threshold = 1">
                            <figcaption>
                                Curve fitting threshold = 1
                            </figcaption>
                        </figure>
                    </td>
                    <td>
                        <figure>
                            <img src="assets/cft10.png" width="270" title="Curve fitting threshold = 10">
                            <figcaption>
                                Curve fitting threshold = 10
                            </figcaption>
                        </figure>
                    </td>
                </tr>
            </table>
            <p>
                The fitted curves and straight lines are stored in SVG format, which is very convenient as it's a
                web-native
                vector file format, and compatible with most
                laser cutting software. It can also easily be converted to other vector formats such as DXF using free
                software.
            </p>
            <h3>Jigsaw style and dimensions</h3>
            <p>
                During the generation process, everything is stored internally in unitless dimensions with no connection
                to
                the
                physical world, and each cell occupies
                exactly 1 square unit of real state in the grid world. This means an N rows x M columns grid world will
                host
                N x M
                cells. You could, in a way, say that
                everything is measured in cell units. However, this has to be translated into the physical world
                somehow,
                both for
                cutting and for preview display.
                The SVG preview is given to the browser in unitless size, which is normally interpreted as pixels. This
                allows for
                the display of large jigsaws on normal screens.
                When you download the SVG, however, it will be set to millimeter units. A unitless internal 100 x 100
                units
                SVG
                file will be downloaded as a 100mm x 100mm
                SVG, with a properly defined physical size for laser cutting. So please be aware that the size shown in
                the
                preview during generation is related to the final jigsaw
                size, but it's not the same. The on-screen size is NOT the jigsaw size. The actual jigsaw dimensions are
                given
                after generation. See the specific sections for
                rectangular and custom border modes for more details about jigsaw dimensions.
            </p>
            <p>
                This generator creates multiple jigsaw styles depending on the <em><strong>Grid size</strong></em>
                parameter. As
                the growth algorithm is size-independent and
                in the end yields dendrites and tentacles about 1 to 3 cells wide, the relative size of the dendrites to
                the
                overall region, combined with the limited growth radius,
                helps create very different jigsaw styles. <em><strong>Grid size</strong></em> below 8 or so will create
                initial
                patterns that will most likely grow very little or not
                at all. <em><strong>Grid size</strong></em> about 10 is the sweet spot for starfish-like pieces, where
                the
                dendrites are comparable in size to the overall piece.
                Larger <em><strong>Grid size</strong></em> while keeping <em><strong>Growth radius</strong></em> not too
                large
                create more dendritic-cell like patterns. Large <em><strong>Grid size</strong></em>
                with a large <em><strong>Growth radius</strong></em> yields very intricate, coral-like pieces. Play with
                the
                parameters to see the different results, as you can see below.
            </p>
            <table class="center">
                <tr>
                    <td>
                        <figure>
                            <img src="assets/grid9.png" width="270" title="Grid size = 9, Growth radius = 20">
                            <figcaption>
                                Grid size = 9, Growth radius = 20
                            </figcaption>
                        </figure>
                    </td>
                    <td>
                        <figure>
                            <img src="assets/grid9100.png" width="270" title="Grid size = 9, Growth radius = 100">
                            <figcaption>
                                Grid size = 9, Growth radius = 100
                            </figcaption>
                        </figure>
                    </td>
                </tr>
                <tr>
                    <td>
                        <figure>
                            <img src="assets/grid18100.png" width="270" title="Grid size = 18, Growth radius = 100">
                            <figcaption>
                                Grid size = 18, Growth radius = 100
                            </figcaption>
                        </figure>
                    </td>
                    <td>
                        <figure>
                            <img src="assets/grid520.png" width="270" title="Grid size = 5, Growth radius = 20">
                            <figcaption>
                                Grid size = 5, Growth radius = 20. It barely grows
                            </figcaption>
                        </figure>
                    </td>
                </tr>
            </table>
            <table class="center">
                <tr>
                    <td>
                        <figure>
                            <img src="assets/grid50100.png" width="540" title="Grid size = 50, Growth radius = 100">
                            <figcaption>
                                Grid size = 50, Growth radius = 100
                            </figcaption>
                        </figure>
                    </td>
                </tr>
            </table>
            <p>
                Please note that these jigsaws are meant to be laser-cut, and small structures may cause trouble. You
                have
                to
                scale things taking real-life material
                behavior into account, so that edge details between pieces have a large enough size for cutting
                properly.
            </p>
            <h3>Rectangular border mode usage</h3>
            <p>
                This is the easiest mode to use, and it will generate rectangular border jigsaws. In this mode, you can
                manipulate
                several parameters. Most of them have already been explained in detail in the previous sections:
            </p>
            <ul>
                <li><strong>Columns and Rows:</strong> set the dimensions, in cells, of the grid world where the cells
                    live.
                </li>
                <li><strong>Grid size:</strong> this is the subgrid size used for initial cell seeding. Read the
                    previous
                    sections
                    for more details.
                </li>
                <li><strong>Initial Grid position noise:</strong> this parameter affects the irregularity of the initial
                    growth
                    pattern, as explained in the previous sections.
                </li>
                <li><strong>Growth radius:</strong> how far away from the initial seed spot can a colony grow, as
                    explained
                    in the
                    previous sections.
                </li>
                <li><strong>Curve fitting threshold:</strong> regulates the tendency of the vectorizer to use straight
                    lines
                    vs
                    curves to fit the cell colony borders, as previously explained.
                </li>
                <li><strong>Magic number:</strong> just leave this at 6.2 ok?</li>
                <li><strong>Actual cell size:</strong> this translates cell units to actual millimeters for SVG
                    download,
                    and to
                    pixels for preview. See below for details.
                </li>
                <li><strong>Cell preview scale:</strong> this translates cell units to pixels for the colored, grid
                    world
                    preview. Each cell will be represented by a
                    <strong>Cell preview scale</strong> x <strong>Cell preview scale</strong> pixels square. Has no
                    effect on
                    the actual vectorized jigsaw, this is just for visualization.
                </li>
            </ul>
            <p>
                To use the generator in this mode, simply select your parameters and press <strong>Generate
                    Jigsaw</strong>.
                The
                initial growth pattern will be generated. Then you may
                start growing the jigsaw, either manually by repeatedly pressing <strong>Grow Jigsaw Manually</strong>
                for
                step-by-step growth, or by pressing <strong>Start Automatic Growth</strong>
                and letting the computer automatically do the step-by-step growth as fast as it can. Once you're
                satisfied,
                <strong>Stop Automatic Growth</strong> if it was enabled, and download your
                results in SVG, ready to laser cut. If you don't like what you see, simply re-adjust the parameters if
                you
                want and
                press <strong>Generate Jigsaw</strong> to start from scratch,
                or just change any parameter (except Columns, Rows, Grid size, and Initial grid position noise) and keep
                growing
                from there. If you press <strong>Generate Jigsaw</strong> to start from scratch,
                everything you had is lost forever. There's no way to save anything, except for the SVG output.
            </p>
            <p>
                The generator will tell you the jigsaw dimensions and total piece count. The dimensions, in millimeters,
                are
                calculated as follows:
            </p>
            <ul>
                <li>
                    Width = <strong>Columns</strong> x <strong>Actual cell size</strong> mm.
                </li>
                <li>
                    Height = <strong>Rows</strong> x <strong>Actual cell size</strong> mm.
                </li>
            </ul>
            <p>
                Being vector graphics, you can of course scale this as you want. It is recommended to keep
                <strong>Actual
                    cell size</strong> above 2 or 3 mm, to get stable pieces without choke points or
                too thin sections that may break easily. For plastics or non-fibrous brittle stuff, definitely keep it
                above
                3 mm.
                If you want a 200x200mm jigsaw for cutting in plywood, you could, for example, set <strong>Columns and
                    Rows</strong> to 100 and <strong>Actual cell size</strong> to 2 mm, or set <strong>Columns and
                    Rows</strong> to 50 and <strong>Actual cell size</strong> to 4 mm.
            </p>
            <h3>Custom border mode usage</h3>
            <p>
                In this mode, the generator will use a custom border for the jigsaw, given by a border SVG file. When
                you
                set this mode, it will prompt you
                to select a custom SVG border file. The SVG border file must be an SVG file defining the intended border
                you
                want to use. It must contain at least one area enclosed by
                strokes, and it may have holes inside. The SVG border file will be preprocessed before generating the
                jigsaw. First, your SVG file will be flattened. That means that all the SVG transforms
                will be applied and burned in, and all the stroke and fill settings will be removed. Every element
                (basic
                shapes, paths) will be stripped of fill and stroke style attributes and set to no fill and a basic black
                stroke. The contents of the files will be moved to the upper left corner and the extent of the drawing
                will
                be set to exactly contain all the elements, like this:
            </p>
            <table class="center">
                <tr>
                    <td>
                        <figure>
                            <img src="assets/originalborder.svg" style="border-style: dotted" width="400"
                                title="Original border file">
                            <figcaption>
                                Original border file
                            </figcaption>
                        </figure>
                    </td>
                    <td>
                        <figure>
                            <img src="assets/unstyled.svg" style="border-style: dotted" width="400"
                                title="Border flattened and style normalized">
                            <figcaption>
                                Border flattened and style normalized
                            </figcaption>
                        </figure>
                    </td>
                </tr>
            </table>
            <table class="center">
                <tr>
                    <td>
                        <figure>
                            <img src="assets/adjusted.svg" style="border-style: dotted" width="400"
                                title="Border position normalized">
                            <figcaption>
                                Border elements position normalized and extent adjusted
                            </figcaption>
                        </figure>
                    </td>
                </tr>
            </table>
            <p>
                Also, your SVG file will be stripped of dimension units information (set to unitless)
                and interpreted as if its dimensions were millimeters. Finally, it will be scaled up or down by the
                <strong>Custom border scale factor</strong>.
            </p>
            <p>
                After the border is preprocessed, a grid world will be created based on the border size, interpreted as
                millimeters, and the <strong>Actual cell size </strong>parameter. For example, if the normalized
                border's extent is 200 by 100 units, it will be interpreted as 200 x 100 mm. If the <strong>Actual cell
                    size</strong> is 1 mm, a rectangular grid world of 200 by 100 cells will be created. If
                <strong>Actual
                    cell size</strong> were 2mm,
                a 100 by 50 cell world would be created instead. Then, the border will be rastered on top of the grid
                world.
                Every grid position where the border passes through will be flagged as a border cell.
            </p>
            <figure>
                <img src="assets/bordertraced.png" width="600" title="Border rasterized on top of the grid world">
                <figcaption>
                    Border rasterized on top of the grid world
                </figcaption>
            </figure>
            <p>
                Once the cell borders are established, a flood-fill algorithm is executed to try to distinguish inside
                from
                outside, and generate the final growth mask for the custom border, like this:
            </p>
            <figure>
                <img src="assets/bordermask.png" width="600" title="Custom Border mask">
                <figcaption>
                    Custom border mask. Cells will only grow in the white area, and not in the black area
                </figcaption>
            </figure>
            <p>
                After the mask is generated, the grid world is seeded (only seeds falling in unmasked areas are allowed
                to
                grow) and the growth proceeds normally from there, within the unmasked areas.
            </p>
            <figure>
                <img src="assets/cb.gif" width="600" title="Custom Border jigsaw growing">
                <figcaption>
                    Custom Border jigsaw growing
                </figcaption>
            </figure>
            <p>
                Hopefully, after this explanation of how things work, you should have grasped an intuition on what kind
                of
                border files will work and not work.
                You may use <a href="https://inkscape.org">Inkscape</a> or any other vector graphics editor to check
                your
                border beforehand. Select every element
                of the border file, remove fill and set the stroke to a simple black line. If you see something with
                clearly
                defined inside and outside areas, with no intersecting
                contours, then it should work well. Anything else should be simplified before. As you may have already
                guessed, whimsical pieces drawn inside of the border will work just fine (unless they're too
                intricate...).
                In fact, the inside part of the example
                border could be considered a whimsical piece.
            </p>
            <p>
                The vectorizing process works exactly the same in this mode as it does in rectangular mode, but the
                custom
                border is also drawn. There's a quirk, though.
                As the cells live in a discrete, grid world, the region borders will start and end at cell boundaries,
                and
                not necessarily exactly over the custom border.
                If you don't do anything else, this is the result of the vectorization process for a custom border
                jigsaw:
            </p>
            <figure>
                <img src="assets/discontinuousborder.svg" width="600" title="Naive vectorization in custom border mode">
                <figcaption>
                    Naive vectorization in custom border mode, with no border snapping.
                </figcaption>
            </figure>
            <p>
                You may have to zoom in to notice, but you will see that the pieces near the border aren't fully cut, as
                the
                ends of their borders don't land exactly on the custom border.
                To fix this, the generator snaps these ends to the border, so that they land exactly on it and the
                pieces
                are fully cut.
            </p>
            <p>
                As a final note, if you want to cut over a print and you have traced out the outline of your image and
                want
                to preserve it as-is with no scaling, you should set the SVG units
                to mm, the extent to exactly surround the border and the <strong>Custom border scale factor</strong> to
                1.
                Then, the exported jigsaw will have the exact same dimensions as the
                border and will be left untouched (except for the style normalization).
            </p>
            <p>
                The settings work essentially in the same way as they do for rectangular border mode. Rows and Columns
                can
                no longer be adjusted, as these
                are calculated based on the border dimensions as explained above. The meaning of <strong>Actual cell
                    size</strong> also changes, as explained
                above. Also, there's a file picker button in case you want to switch the custom border to a different
                one.
            </p>
            <h2>FAQ</h2>
            <p><strong>Where are my border files uploaded?</strong></p>
            <p>Nowhere. It all stays on your computer, the border file is just loaded into your browser and used
                exclusively within the browser. You're basically
                downloading a self-contained webapp and executing it locally, in fact you can download this for totally
                offline use, see below.
            </p>
            <p><strong>Is this free?</strong></p>
            <p>Yes, it is. The code falls under the <a
                    href="https://raw.githubusercontent.com/proceduraljigsaw/OrganicPuzzleJs/main/LICENSE">MIT
                    license</a></p>
            <p><strong>Where can I get the code?</strong></p>
            <p><a href="https://github.com/proceduraljigsaw/OrganicPuzzleJs">Here</a></p>
            <p><strong>Can I use it offline somehow?</strong></p>
            <p>Sure, this is all executed in your browser. Just clone the github repo or right-click save the web from
                your browser. It will download all the required assets,
                and you may run it by just opening index.html using your favorite browser.
            </p>
            <p><strong>Which browsers are supported?</strong></p>
            <p>As far as I know, any modern browser should work. It's been tested on the most up to date versions (April
                2022) of Firefox, Chrome, Edge, and Safari.
            </p>
            <p><strong>Is this all your job?</strong></p>
            <p>No, I use two third-party libraries.</p>
            <ul>
                <li>
                    A heavily modified and stripped down version of <a
                        href="https://github.com/jankovicsandras/imagetracerjs">imagetracerjs</a> 1.2.6 for
                    vectorization.
                </li>
                <li>
                    <a href="https://gist.github.com/timo22345/9413158">Flatten.js</a> for SVG transform flattening.
                </li>
            </ul>
            <p><strong>Any known issues?</strong></p>
            <p>
                Many. This should be considered beta software, use with caution. I recommend cutting in cheap material
                before committing for a design, to see any
                potential issues before wasting expensive material. I'm not responsible for any material waste. Here's a
                list of known issues:
            </p>
            <ul>
                <li>
                    Sometimes the vectorizer creates micro-loops at border pieces in custom border mode.
                </li>
                <li>
                    There's a very rare case that's not well handled by the vectorizer, making it miss a line and
                    leaving one piece open. It's extremely rare, but it's
                    in the pipeline for fixing.
                </li>
                <li>
                    I really don't know how or why the growth algorithm works. I came into it by accident, while trying
                    different approaches, and I'm not really sure why
                    setting a parameter to 6.2 makes things work.
                </li>
            </ul>
            <p><strong>Do you have any other jigsaw generators for different jigsaw styles?</strong></p>
            <p>Sure, <a href="https://github.com/proceduraljigsaw">go suit yourself</a> </p>
            <p><strong>I meant normal puzzles, with rectangular pieces with tabs</strong></p>
            <p>Then unfortunately no, but draradech <a href="https://draradech.github.io/jigsaw/index.html">has a very
                    good one</a>, and it's also free. </p>
            <p><strong>How can I contact you?</strong></p>
            <p>Use whatever tools github provides <a href="https://github.com/proceduraljigsaw/OrganicPuzzleJs">here</a>
                to report bugs or whatever you find.
            </p>
        </div>
    </div>

    
    <script>
        document.getElementById("default").click();
    </script>
    <svg id="svgcontainer"></svg>
    <canvas id="automata"></canvas>
    <div id="layercnt"></div>

</body>

</html>