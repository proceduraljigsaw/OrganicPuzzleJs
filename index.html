<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>CelljigsawJS</title>
    <script type="text/javascript" src="imagetracer.js"></script>
    <script type="text/javascript" src="flatten.js"></script>
    <script type="text/javascript">

        var xmldoc = null;
        function $(id) { return document.getElementById(id); }
        function random() {
            return Math.random();
        }
        function uniform(min, max) { var ran = random(); return min + ran * (max - min); }
        function rbool() { return random() > 0.5; }
        function Shuffle(arr) {
            for (var i = arr.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1)); //random index
                [arr[i], arr[j]] = [arr[j], arr[i]]; // swap
            }
        }

        function plotpath(path, scale) {
            var len = path.getTotalLength();
            var ancestor = path.ownerSVGElement;
            let cp = [];
            let uinc = 0.0078125;
            for (let u = 0; u <= 1; u += uinc) {
                let p = path.getPointAtLength(u * len);
                p.rx = p.x;
                p.ry = p.y;
                p.x = Math.round(p.x / scale);
                p.y = Math.round(p.y / scale);
                p.u = u;
                p.path = path;
                if (cp.length && (Math.abs(cp[cp.length - 1].x - p.x) > 1 || Math.abs(cp[cp.length - 1].y - p.y) > 1)) {
                    //Lacking raster resolution
                    u -= uinc;
                    uinc = uinc / 2;
                    //console.log("uinc " + uinc);
                    if (uinc < 0.0000152587890625) {
                        uinc = 0.0078125;
                        cp.push(p);
                    }
                } else {
                    cp.push(p);
                }

            }
            return cp;
        }

        class Automata {
            constructor(rows, columns, border) {
                if (border.paths) {
                    columns = Math.ceil(border.width) + 1;
                    rows = Math.ceil(border.height) + 1;
                }
                this.rows = rows;
                this.columns = columns;
                this.max_growth_dist = 0;
                let Array2D = (row, col) => [...Array(row)].map(x => Array(col).fill(0));
                this.grid = Array2D(rows, columns);
                //this.edgegrid = Array2D(rows, columns);
                this.seedpoints = [];
                this.colorArray = [];
                this.cornertable = [];
                this.cornergrid = Array2D(rows, columns);
                this.maskgrid = Array2D(rows, columns);
                this.borderdistgrid = Array2D(rows, columns);
                this.lockedgrid = Array2D(rows, columns);
                if (border.paths) {
                    this.fillmask(border.paths);
                }

            }

            fillmask(paths) {
                const crosslookup = [[-1, 0], [1, 0], [0, 1], [0, -1]];

                var allpts = []
                var minx, miny, maxx, maxy
                for (let p of paths) {
                    var pts = plotpath(p, 1);
                    pts.forEach((pt) => {
                        allpts.push(pt);
                        if (isNaN(minx) || pt.x < minx) minx = pt.x;
                        if (isNaN(miny) || pt.y < miny) miny = pt.y;
                        if (isNaN(maxx) || pt.x > maxx) maxx = pt.x;
                        if (isNaN(maxy) || pt.y > maxy) maxy = pt.y;
                    });

                }
                // console.log("V", minx, maxx, miny, maxy);
                allpts.forEach((p) => {
                    // console.log(this.borderdistgrid.length, this.borderdistgrid[0].length,p.x,p.y)
                    this.borderdistgrid[p.y][p.x] = p;
                    this.maskgrid[p.y][p.x] = 1;

                });

                var regnum = 3;

                var grown;
                do {
                    var outside = true;
                    grown = false;
                    for (var i = -1; i < this.rows + 1; i++) {
                        for (var j = -1; j < this.columns + 1; j++) {
                            if (i < 0 || j < 0 || i > this.rows - 1 || j > this.columns - 1 || (this.maskgrid[i][j] > 1 && this.maskgrid[i][j] < regnum)) {
                                var togrow = [{ r: i, c: j }];
                                do {
                                    var p = togrow.pop();
                                    crosslookup.forEach((c) => {
                                        var ii = p.r + c[0];
                                        var jj = p.c + c[1];
                                        if (ii >= 0 && jj >= 0 && ii < this.rows && jj < this.columns) {

                                            if (!this.maskgrid[ii][jj]) {
                                                togrow.push({ r: ii, c: jj });
                                            }
                                            if (this.maskgrid[ii][jj] < 2) {
                                                if (p.r > 0 && p.c > 0 && p.r < this.rows && p.c < this.columns) {
                                                    if (this.maskgrid[p.r][p.c] > 1 && this.maskgrid[p.r][p.c] < regnum && this.maskgrid[p.r][p.c] % 2) {
                                                        this.outside = false;
                                                    }
                                                } else {
                                                    this.outside = true;
                                                }
                                                this.maskgrid[ii][jj] = regnum;
                                                grown = true;
                                            }
                                        }
                                    });
                                } while (togrow.length);

                            }
                        }

                    }
                    regnum += outside ? 1 : 2;
                } while (grown)

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {
                        this.maskgrid[i][j] = this.maskgrid[i][j] % 2;
                    }
                }
                allpts.forEach((p) => {
                    this.maskgrid[p.y][p.x] = 1;
                });
            }
            gridseed(gsize, randlen) {
                this.seedpoints = []
                var val = 1;
                for (var i = gsize / 2; i <= this.rows - gsize / 2; i += gsize) {
                    for (var j = gsize / 2; j <= this.columns - gsize / 2; j += gsize) {
                        var row = Math.round(i + uniform(-(gsize / 2) * randlen, (gsize / 2) * randlen)) % this.rows;
                        var col = Math.round(j + uniform(-(gsize / 2) * randlen, (gsize / 2) * randlen)) % this.columns;
                        if (row < 0) row += this.rows;
                        if (col < 0) col += this.columns;

                        if (!this.maskgrid[row][col]) {
                            this.grid[row][col] = val;
                            this.seedpoints.push({ row: row, col: col, val: val });
                            val = val + 1;
                        }

                    }
                }
                $("piececount").innerHTML = val - 1;
            }

            step(context, prefill) {
                var growth = []
                var growthdistchanged = (this.max_growth_dist != parseInt($("gradius").value));
                var ii = Math.floor(uniform(0, this.rows));
                var ij = Math.floor(uniform(0, this.columns));
                var fi = ii + this.rows;
                var fj = ij + this.columns;
                var reverse = rbool() && !prefill;
                if (growthdistchanged) {
                    for (var i = 0; i < this.rows; i++) {
                        for (var j = 0; j < this.columns; j++) {
                            this.lockedgrid[i][j] = 0;
                        }
                    }
                }
                this.max_growth_dist = parseInt($("gradius").value);
                if (prefill) {
                    ii = 0;
                    ij = 0;
                    fi = this.rows;
                    fj = this.columns;
                }
                if (reverse) {
                    for (var i = fi - 1; i >= ii; i--) {
                        for (var j = fj - 1; j >= ij; j--) {
                            var ti = i % this.rows;
                            var tj = j % this.columns;
                            if (this.grid[ti][tj] > 0 && !this.lockedgrid[ti][tj]) {
                                this.grow(ti, tj, growth, context, prefill);
                            }
                        }
                    }
                } else {
                    for (var i = ii; i < fi; i++) {
                        for (var j = ij; j < fj; j++) {
                            var ti = i % this.rows;
                            var tj = j % this.columns;
                            if (this.grid[ti][tj] > 0 && !this.lockedgrid[ti][tj]) {
                                this.grow(ti, tj, growth, context, prefill);
                            }
                        }
                    }
                }
                growth.forEach((grow) => {
                    this.grid[grow.row][grow.col] = grow.val;
                    var neigh = this.neighbor_coords(grow.row, grow.col)
                    neigh.forEach((n) => {
                        this.lockedgrid[n.row][n.col] = 0;
                    });
                });
                // if (!prefill) {
                //     this.edgefind(context);
                // }
                return growth.length
            }

            mindistandclosestpoint2path(corner) {

                var neighbor_coords = this.neighbor_coords(corner.row, corner.col);
                neighbor_coords.push(corner);
                let mind = 1e12
                let cp = null;
                let d = 0;
                neighbor_coords.forEach((nc) => {
                    let bg = this.borderdistgrid[nc.row][nc.col];
                    if (bg) {
                        // var len = bg.path.getTotalLength();
                        // for (let u = bg.u - 0.01; u <= bg.u + 0.01; u += 0.005) {
                        //     let p = bg.path.getPointAtLength(u * len);
                        d = Math.hypot(bg.rx - corner.col, bg.ry - corner.row)
                        if (d < mind) {
                            mind = d;
                            cp = { x: bg.rx, y: bg.ry };
                        }
                        // }
                    }
                });

                return { d: mind, cp: cp };
            }


            neighbor_coords(row, col) {
                var coords = [];
                for (var i = -1; i < 2; i++) {
                    for (var j = -1; j < 2; j++) {
                        var pr = row + i;
                        var pc = col + j;
                        if ((i || j) && pr >= 0 && pc >= 0 && pr < this.rows && pc < this.columns) {
                            coords.push({ row: pr, col: pc });
                        }
                    }
                }
                return coords;
            }

            findcorners(customborder) {
                const lookup = [[[1, 1], [0, 1], [1, 0]], [[-1, -1], [0, -1], [-1, 0]], [[1, -1], [0, -1], [1, 0]], [[-1, 1], [0, 1], [-1, 0]]];
                var corners = [];
                let Array2D = (row, col) => [...Array(row)].map(x => Array(col).fill(0));
                this.cornergrid = Array2D(this.rows + 1, this.columns + 1);
                for (var i = -1; i < this.rows + 1; i++) {
                    for (var j = -1; j < this.columns + 1; j++) {
                        var corner_cand = [];

                        lookup.forEach((le) => {
                            if (i < 0 || j < 0 || j >= this.columns || i >= this.rows) {
                                var distinct = [0];
                            } else {
                                var distinct = [this.grid[i][j]];

                            }
                            le.forEach((c) => {
                                var ii = i + c[0];
                                var jj = j + c[1];
                                if (ii < 0 || jj < 0 || ii >= this.rows || jj >= this.columns) {
                                    if (!distinct.includes(0)) {
                                        distinct.push(0);
                                    }
                                } else {
                                    var val = this.grid[ii][jj];
                                    if (!distinct.includes(val)) {
                                        distinct.push(val);
                                    }
                                }
                            });
                            if (distinct.length > 2) {
                                var c = le[0];
                                var cr = c[0] > 0 ? c[0] : 0;
                                var cc = c[1] > 0 ? c[1] : 0;
                                var onborder = distinct.includes(0);
                                corner_cand.push({ row: i + cr, col: j + cc, onborder: onborder });
                            }
                        });

                        if (corner_cand.length == 1 && !this.cornergrid[corner_cand[0].row][corner_cand[0].col]) {
                            this.cornergrid[corner_cand[0].row][corner_cand[0].col] = 1;
                            corners.push(corner_cand[0]);
                        }
                    }
                }
                this.cornertable = [];
                if (customborder.paths) {
                    corners.forEach((c) => {
                        if (c.onborder) {
                            var mind = 2e9;
                            var newp = { x: c.col, y: c.row };
                            for (let p of customborder.paths) {
                                var dcp = this.mindistandclosestpoint2path(c);
                                if (dcp && dcp.d < mind) {
                                    mind = dcp.d;
                                    newp = dcp.cp;
                                }
                            }
                            this.cornertable.push({ row: c.row, col: c.col, x: newp.x, y: newp.y });
                        }
                    });
                }
                return corners;
            }
            grow(row, col, growth, context, prefill) {

                var neigh_coord = this.neighbor_coords(row, col);
                var grown = [];
                var currentcellval = this.grid[row][col]
                var seed = this.seedpoints.find((sp) => sp.val == currentcellval);

                var sc_neigh = 0;
                var sc_neigh_in_corner = 0;
                var other_color = 0;
                neigh_coord.forEach((neighbor) => {
                    if (this.grid[neighbor.row][neighbor.col]) {
                        if (Math.abs(this.grid[neighbor.row][neighbor.col]) == currentcellval) {
                            sc_neigh++;
                            if (neighbor.row != row && neighbor.col != col) {
                                sc_neigh_in_corner++;
                            }
                        } else {
                            other_color = Math.abs(this.grid[neighbor.row][neighbor.col]);
                        }
                    }
                });
                if (sc_neigh == neigh_coord.length) {
                    this.lockedgrid[row][col] = 1;
                } else {
                    if (!prefill && sc_neigh < 3) {
                        //Cell dies immediately if it's alone (2 neighbors of the same color or less) We don't want it to grow
                        //This avoids issues with spurious growth
                        if (sc_neigh_in_corner == sc_neigh && !this.maskgrid[row][col]) {
                            this.grid[row][col] = -other_color;
                            growth.push({ row: row, col: col, val: other_color });
                        }
                    } else if (prefill || Math.random() < parseFloat($("growth_prob").value)) {
                        //We have enough neighbors, explore them
                        neigh_coord.forEach((neighbor) => {

                            if (prefill || neighbor.row == row || neighbor.col == col) {
                                var dist2seed = Math.sqrt((neighbor.row - seed.row) ** 2 + (neighbor.col - seed.col) ** 2);
                                var neighborval = this.grid[neighbor.row][neighbor.col];

                                if (!this.maskgrid[neighbor.row][neighbor.col] && (prefill || (dist2seed < this.max_growth_dist))) {
                                    //We're close enough to the seed point, lets try to grow

                                    if (!neighborval) { //neighbor is empty 
                                        //Just eat it  
                                        growth.push({ row: neighbor.row, col: neighbor.col, val: currentcellval });
                                        grown.push({ row: neighbor.row, col: neighbor.col });
                                    } else if (!prefill && neighborval > 0 && (Math.abs(currentcellval) != Math.abs(neighborval))) { //neighbor is taken by other piece
                                        //see if we can kill it and overtake
                                        var nnc = this.neighbor_coords(neighbor.row, neighbor.col);
                                        //get neighbor's neighbors of the same color;
                                        nnc = nnc.filter(nn => (Math.abs(this.grid[nn.row][nn.col]) == neighborval));
                                        var nnc_len = nnc.length;
                                        if (nnc_len > 2 && nnc_len < 6) {
                                            var nnnc_len = 0;
                                            nnc.forEach((n) => {
                                                var nnnc = this.neighbor_coords(n.row, n.col);
                                                nnnc = nnnc.filter(nn => (Math.abs(this.grid[nn.row][nn.col]) == neighborval));
                                                nnnc_len += nnnc.length;
                                            });


                                            //I don't know how the 6.2 thing works, but it seems to work. This algorithm was empirically found
                                            if (nnnc_len / nnc_len > parseFloat($("mnumber").value)) {
                                                //console.log(nnnc_len + " " + nnc_len + " " + neighborval);
                                                growth.push({ row: neighbor.row, col: neighbor.col, val: currentcellval });
                                                grown.push({ row: neighbor.row, col: neighbor.col });
                                            }
                                        }
                                    }

                                }
                            }
                        });
                        if (!prefill && grown.length == 0) {
                            this.lockedgrid[row][col] = 1;
                        }
                    }

                    //TODO: If your only growth is a corner, don't grow DONE
                    if (grown.length == 1 && grown[0].row != row && grown[0].col != col) {
                        grown = [];
                        growth.pop();
                    }
                    grown.forEach((grow) => {
                        this.grid[grow.row][grow.col] = -this.grid[row][col];
                    });
                }
            }
            paintcorners(context, corners, size) {
                var pixelsize = parseInt($("pixelscell").value);
                corners.forEach((c) => {
                    context.fillStyle = "black";
                    context.fillRect((c.col * pixelsize) - size / 2, (c.row * pixelsize) - size / 2, size, size);
                });
            }
            findedgestep(edge, row, col, pdir, corner, context) {
                var pixelsize = parseInt($("pixelscell").value);
                if (row < 0 || col < 0 || row >= this.rows || col >= this.columns) {
                    return;
                }
                if (!corner && this.cornergrid[row][col] == 1) {
                    return;
                }
                if (pdir.includes("E")) {
                    //move east
                    var ii = row - 1;
                    var jj = col;
                    var v1 = this.grid[row][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row][col + 1] < 2) {
                            if (!this.cornergrid[row][col + 1])
                                this.cornergrid[row][col + 1] = 2;
                            edge.push({ row: row, col: col + 1 });
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo((col + 1) * pixelsize, (row) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row, col + 1, "NSE", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("W")) {
                    //move west
                    var ii = row - 1;
                    var jj = col - 1;
                    var v1 = (col - 1) < 0 ? 0 : this.grid[row][col - 1];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row][col - 1] < 2) {
                            if (!this.cornergrid[row][col - 1])
                                this.cornergrid[row][col - 1] = 2;
                            edge.push({ row: row, col: col - 1 });
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo((col - 1) * pixelsize, (row) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row, col - 1, "NSW", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("N")) {
                    //move north
                    var ii = row - 1;
                    var jj = col - 1;
                    var v1 = (row - 1) < 0 ? 0 : this.grid[row - 1][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row - 1][col] < 2) {
                            if (!this.cornergrid[row - 1][col])
                                this.cornergrid[row - 1][col] = 2;
                            edge.push({ row: row - 1, col: col });
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo(col * pixelsize, (row - 1) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row - 1, col, "NEW", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("S")) {
                    //move south
                    var ii = row;
                    var jj = col - 1;
                    var v1 = this.grid[row][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row + 1][col] < 2) {
                            if (!this.cornergrid[row + 1][col])
                                this.cornergrid[row + 1][col] = 2;
                            edge.push({ row: row + 1, col: col });
                            context.strokeStyle = "black";

                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo(col * pixelsize, (row + 1) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row + 1, col, "SEW", false, context);
                        }
                        return; //only one movement!
                    }

                }

            }
            findedges(corners, context) {
                var edgepaths = [];
                var shortedgepaths = [];
                const directions = ["N", "S", "E", "W"];
                var pixelsize = parseInt($("pixelscell").value);
                corners.forEach((c) => {

                    var size = 8;
                    context.fillStyle = c.customborder ? "red" : "blue";
                    context.fillRect((c.col * pixelsize) - size / 2, (c.row * pixelsize) - size / 2, size, size);
                    // if (!c.customborder) {
                    directions.forEach((d) => {
                        var edge = [c];
                        this.findedgestep(edge, c.row, c.col, d, true, context);

                        if (edge.length > 1) {
                            if (edge.length == 2) {
                                var sameedge = shortedgepaths.filter(sep => (
                                    (sep[0].row == edge[0].row && sep[0].col == edge[0].col && sep[1].row == edge[1].row && sep[1].col == edge[1].col) ||
                                    (sep[1].row == edge[0].row && sep[1].col == edge[0].col && sep[0].row == edge[1].row && sep[0].col == edge[1].col)
                                ));
                                if (!sameedge.length) {
                                    edgepaths.push(edge);
                                    shortedgepaths.push(edge);
                                }
                            } else {
                                edgepaths.push(edge);
                            }
                        }
                        //.log("Edged");
                    });
                    // }
                });
                return edgepaths;
            }
            paint(context, palette) {
                var pixelsize = parseInt($("pixelscell").value);
                context.clearRect(0, 0, $("automata").width, $("automata").height);
                context.font = "12px Arial";
                context.textAlign = "center";

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {

                        if (this.grid[i][j] < 0) {
                            console.log("WTF");
                        }

                        if (this.grid[i][j]) {
                            context.fillStyle = this.colorArray[Math.abs(this.grid[i][j] - 1) % this.colorArray.length];
                            context.fillRect(j * pixelsize, i * pixelsize, pixelsize, pixelsize);

                        }
                    }
                }
            }

            paintmask(context) {
                var pixelsize = parseInt($("pixelscell").value);
                context.clearRect(0, 0, $("automata").width, $("automata").height);
                context.font = "12px Arial";
                context.textAlign = "center";

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {

                        if (this.maskgrid[i][j] < 0) {
                            console.log("WTF");
                        }

                        if (this.maskgrid[i][j] % 2) {
                            context.fillStyle = "red";

                        } else {
                            context.fillStyle = "blue";
                        }

                        context.fillRect(j * pixelsize, i * pixelsize, pixelsize, pixelsize);



                    }
                }
            }
        }
        var canvas;
        var automata;
        var palette;
        var svgstr;
        var context;
        var customborder = {};
        // save function pieced together from here: https://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link
        function save(filename, data) {
            var blob = new Blob([data], { type: "image/svg+xml" });
            if (window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveBlob(blob, filename);
            }
            else {
                var elem = window.document.createElement('a');
                elem.href = window.URL.createObjectURL(blob);
                elem.download = filename;
                document.body.appendChild(elem);
                elem.click();
                document.body.removeChild(elem);
            }
        }

        function savesvg() {
            save("jigsaw.svg", svgstr);
        }

        function generate() {
            var pixelsize = parseInt($("pixelscell").value);
            if (customborder.svgdata) {
                while ($("svgcontainer").firstChild) {
                    $("svgcontainer").removeChild($("svgcontainer").firstChild);
                }

                var svgdata = document.body.appendChild(customborder.svgdata);
                //Initial flattening to get rid of transforms
                flatten(svgdata, false, true);

                var paths_svg = svgdata.getElementsByTagName("path");
                var pgroup = document.createElementNS($("svgcontainer").namespaceURI, "g");
                //When all transforms have been applied for all paths, the remaining one is the viewbox/viewport thing
                var vt = paths_svg[0].getCTM();
                $("svgcontainer").append(pgroup);

                for (let p of paths_svg) {
                    var newpath = document.createElementNS($("svgcontainer").namespaceURI, "path")
                    newpath.setAttribute("d", p.getAttribute('d'));
                    newpath.setAttribute("stroke", "black");
                    newpath.setAttribute("stroke-width", 1);
                    newpath.setAttribute("fill", "none");
                    pgroup.appendChild(newpath);
                }

                document.body.removeChild(svgdata);
                //De-viewboxfy
                pgroup.setAttribute("transform", "matrix(" + vt.a + "," + vt.b + "," + vt.c + "," + vt.d + "," + vt.e + "," + vt.f + ")");
                flatten($("svgcontainer"), false, true);
                //Scale
                pgroup.setAttribute("transform", "scale(" + parseFloat($("cbsf").value) + ")");
                flatten($("svgcontainer"), false, true);
                //To left corner
                pgroup.setAttribute("transform", "translate(" + (-($("svgcontainer").getBBox().x)) + "," + (-($("svgcontainer").getBBox().y)) + ")");
                flatten($("svgcontainer"), false, true);
                //Now the customborder is normalized

                customborder.width = ($("svgcontainer").getBBox().width + $("svgcontainer").getBBox().x);// * pixelsize;
                customborder.height = ($("svgcontainer").getBBox().height + $("svgcontainer").getBBox().y);// * pixelsize;

                customborder.paths = pgroup.getElementsByTagName("path");
            }
            var rows = parseInt($("nrows").value);
            var cols = parseInt($("ncols").value);

            var gsize = parseInt($("gsize").value);
            var gnoise = parseFloat($("gnoise").value);

            automata = new Automata(rows, cols, customborder);
            if (customborder.svgdata) {
                pgroup.setAttribute("transform", "scale(" + parseFloat($("cell_scale").value) + ")");
                flatten($("svgcontainer"), false, true);
            }
            rows = automata.rows;
            cols = automata.columns;
            canvas = $("automata");
            canvas.setAttribute("width", cols * pixelsize + 5);
            canvas.setAttribute("height", rows * pixelsize + 5);// * 2);


            if (canvas.getContext) {
                context = canvas.getContext('2d');


                if (customborder.paths) {
                    automata.paintmask(context);
                }
                automata.gridseed(gsize, gnoise);
                palette = ImageTracer.generatepalette(automata.seedpoints.length + 1);
                Shuffle(palette);
                palette.forEach((c) => {
                    automata.colorArray.push("#" + c.r.toString(16).toUpperCase().padStart(2, "0") + c.g.toString(16).toUpperCase().padStart(2, "0") + c.b.toString(16).toUpperCase().padStart(2, "0"));
                });

                automata.paint(context, palette);
                var growncells = 0;
                do {
                    growncells = automata.step(context, true);
                    //automata.paint(context);
                } while (growncells);
                paintoutput();
            }
        }

        function paintoutput() {
            var rows = automata.rows;
            var cols = automata.columns;
            var pixelsize = parseInt($("pixelscell").value);
            var cellscale = parseInt($("cell_scale").value);
            canvas = $("automata");
            canvas.setAttribute("width", cols * pixelsize + 5);
            canvas.setAttribute("height", rows * pixelsize + 5);// * 2);
            $("svgcontainer").setAttribute("width", cols * cellscale);
            $("svgcontainer").setAttribute("height", rows * cellscale);
            automata.paint(context, palette);
            console.log("Painted");
            var corners = automata.findcorners(customborder);
            console.log("Cornered");

            var edges = automata.findedges(corners, context);
            console.log("Edged");

            var paths = [];
            //convert to how svgtracejs wants this
            edges.forEach((e) => {
                var path = {};
                path.points = [];
                path.boundingbox = [];
                path.holechildren = [];
                path.isholepath = false;
                var minx = 1e9, miny = 1e9, maxx = 0, maxy = 0;
                e.forEach((p) => {
                    path.points.push({ x: p.col, y: p.row });
                    if (p.col > maxx) maxx = p.col;
                    if (p.col < minx) minx = p.col;
                    if (p.row > maxy) maxy = p.row;
                    if (p.row < miny) miny = p.row;
                });
                path.boundingbox = [minx, miny, maxx, maxy];
                paths.push(path);
            });
            var options = { pal: palette, scale: cellscale, ltres: 0.00001, qtres: parseFloat($("qtres").value), strokewidth: .5, linefilter: false, rightangleenhance: false, layering: 0, layercontainerid: "layercnt" };

            // Getting ImageData from canvas with the helper function getImgdata().
            svgstr = ImageTracer.pathsToSVG(paths, customborder, automata.cornertable, automata.columns, automata.rows, options);
            console.log("SVG'd");

            // Synchronous tracing to SVG string 
            //var svgstr = ImageTracer.gridToSVG(automata.grid, palette, options);
            while ($("svgcontainer").firstChild) {
                $("svgcontainer").removeChild($("svgcontainer").firstChild);
            }
            // Appending SVG
            ImageTracer.appendSVGString(svgstr, 'svgcontainer');
        }

        function growstep() {
            growncells = automata.step(context, false);
            console.log("Grown");
            paintoutput();

        }

        function unloadborder() {
            customborder = {};
        }

        function loadborder() {
            var borderfile = $("borderfile");
            var fr = new FileReader();
            fr.readAsText(borderfile.files[0]);
            fr.onload = function () {
                //console.log(fr.result);
                var parser = new DOMParser();
                xmldoc = parser.parseFromString(fr.result, "image/svg+xml");
                var svgdata_p = xmldoc.getElementsByTagName("svg")[0];
                customborder.svgdata = svgdata_p;
            };
        }


    </script>
</head>

<body>
    <table>
        <tr>
            Need help? Check the github repository readme <a
                href="https://github.com/proceduraljigsaw/OrganicPuzzleJs">here</a>.
        </tr>
        <tr>
            <td>Columns:</td>
            <td><input id="ncols" type="text" value="100" /> cells</td>
        </tr>
        <tr>
            <td>Rows:</td>
            <td><input id="nrows" type="text" value="100" /> cells</td>
        </tr>
        <tr>
            <td>Grid size:</td>
            <td><input id="gsize" type="text" value="10" /> cells</td>
        </tr>
        <tr>
            <td>Initial Grid position noise (0 to 1):</td>
            <td><input id="gnoise" type="text" value="0.9" /></td>
        </tr>
        <tr>
            <td>Growth radius:</td>
            <td><input id="gradius" type="text" value="20" /> cells</td>
        </tr>
        <tr>
            <td>Curve fitting threshold (must be >0, float):</td>
            <td><input id="qtres" type="text" value="1" /></td>
        </tr>
        <tr>
            <td>Magic number(just leave it at 6.2):</td>
            <td><input id="mnumber" type="text" value="6.2" /></td>
        </tr>
        <tr>
            <td>Growth probability (0 to 1):</td>
            <td><input id="growth_prob" type="text" value="0.5" /></td>
        </tr>
        <tr>
            <td>Cell size (mm):</td>
            <td><input id="cell_scale" type="text" value="2" /></td>
        </tr>
        <tr>
            <td>Preview Viewing scale (pixels/cell):</td>
            <td><input id="pixelscell" type="text" value="2" /></td>
        </tr>
        <tr>
            <td>Pick a custom border SVG file:</td>
            <td><input type="file" id="borderfile" accept=".svg"></td>
        </tr>
        <tr>
            <td>Custom border scale factor:</td>
            <td><input id="cbsf" type="text" value="1" size="4" /></td>
        </tr>
        <tr>
            <td><button onclick="loadborder()">Load custom border</button></td>
            <td><button onclick="unloadborder()">Unload custom border</button></td>
        </tr>
        <tr>
            <td><button onclick="generate()">Generate Jigsaw</button></td>
        </tr>
        <tr>
            <td><button onclick="growstep()">Grow Jigsaw</button></td>
        </tr>
        <tr>
            <td><button onclick="savesvg()">Download SVG (non-overlapping vectors)</button></td>
        </tr>
        <tr>
            <td>This jigsaw has: <label id="piececount">0</label> pieces</td>
        </tr>
    </table>


    <svg id="svgcontainer"></svg>
    <canvas id="automata"></canvas>
    <div id="layercnt"></div>
</body>

</html>